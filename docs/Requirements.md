### **ルート最適化Webアプリケーション MVP 要求仕様書 (車両数1台/TSP)**

### I. プロジェクト概要

| 項目                     | 詳細                                                                                                                                                                                         |
| :----------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **アプリケーション名**   | MVP ルート最適化ツール (TSP Solver)                                                                                                                                                          |
| **目的**                 | 複数の訪問地点（配送先）に対して、1台の車両が Depot（出発/帰着地点）から出発し、全ての地点を巡回して Depot に戻る**最短のルートを計算**し、その結果を**Webアプリケーション上で視覚化**する。 |
| **対象ユーザー**         | 小規模な配送業務を持つ事業者、個人の配送計画担当者、ルートプランナー。                                                                                                                       |
| **車両数 (MVPスコープ)** | 1台 (巡回セールスマン問題, TSP)。                                                                                                                                                            |
| **最適化目標**           | **総移動距離の最小化**。                                                                                                                                                                     |

---

### II. 機能要件 (Functional Requirements)

#### A. データ入力・準備 (Data Input & Preparation)

| ID      | 機能要件           | 詳細と最小実装の方向性                                                                                                                                                                                                                                  |
| :------ | :----------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **A-1** | **地点登録**       | ユーザーが地図上をクリックすることで地点を登録できる。<br>・**Depot（始点/終点）と訪問地点を区別**して登録できる（例：最初のクリックをDepot、以降を訪問地点とする）。<br>・登録した地点を個別に削除できる。                                             |
| **A-2** | **地点情報の保持** | 登録された地点の緯度・経度情報をフロントエンドのステートとして保持する。                                                                                                                                                                                |
| **A-3** | **距離行列の生成** | 全ての登録地点間の移動コスト（距離）を示す**距離行列 (Distance Matrix)** をバックエンドで生成する。<br>・**MVP実装**では、OSRM (Open Source Routing Machine) の公開APIを利用し、実道路網に基づいた距離を取得する。APIの利用規約とレート制限に留意する。 |
| **A-4** | **車両設定**       | 車両数は固定で「1」とする。UI上での設定は不要。                                                                                                                                                                                                         |

#### B. 最適化実行 (Optimization Execution)

| ID      | 機能要件           | 詳細と最小実装の方向性                                                                                                   |
| :------ | :----------------- | :----------------------------------------------------------------------------------------------------------------------- |
| **B-1** | **最適化の実行**   | ユーザーが「計算開始」ボタンをクリックすると、入力データ（地点、距離行列）に基づき、バックエンドで最適ルートを計算する。 |
| **B-2** | **制約条件 (MVP)** | 1. 全ての訪問地点を1度ずつ訪問する。<br>2. Depot から出発し、全ての訪問地点を巡回した後に Depot に戻る。                 |
| **B-3** | **最適化エンジン** | **Google OR-Tools** のルーティングライブラリ（Python バインディング）を使用し、TSPを解く。                               |

#### C. 結果出力・視覚化 (Result Output & Visualization)

| ID      | 機能要件               | 詳細と最小実装の方向性                                                                                                                          |
| :------ | :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------- |
| **C-1** | **ルートの表示**       | 最適化されたルート（Depot → 地点1 → 地点2 → ... → Depot）を、OSRMから取得したルートジオメトリを用いて地図上にポリラインで描画する。             |
| **C-2** | **訪問順序の表示**     | 巡回する地点の順序をリスト形式で表示する（例：「Depot → 3. 〇〇商店 → 1. △△ビル → ... → Depot」）。地図上のマーカーにも訪問順の番号を表示する。 |
| **C-3** | **サマリー情報の表示** | 計算された**総移動距離 (km)** を表示する。                                                                                                      |
| **C-4** | **地図基盤**           | **Leaflet.js** と **OpenStreetMap (OSM)** のタイルレイヤーを使用し、地図表示のライセンスコストをゼロにする。                                    |

---

### III. 技術スタック (Technical Stack)

| 領域                     | 推奨技術                               | 備考/理由                                                                                                                                                                  |
| :----------------------- | :------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **最適化エンジン**       | **Google OR-Tools** (Python)           | VRP/TSPの解法に実績があり、高速かつ高精度。Pythonでの利用が容易。                                                                                                          |
| **Web バックエンド**     | **Python (Flask)**                     | OR-Toolsとの親和性が高く、軽量なFlaskがMVPのAPIサーバーとして適任。                                                                                                        |
| **フロントエンド**       | **React + TypeScript**                 | コンポーネント管理が容易で、型安全性によりバグを減らせる。MVPでも保守性を考慮。                                                                                            |
| **地図ライブラリ**       | **Leaflet.js**                         | 軽量で高機能なオープンソースの地図ライブラリ。                                                                                                                             |
| **地図データ**           | **OpenStreetMap (OSM)**                | ライセンス費用が発生しない地図データ。                                                                                                                                     |
| **距離計算・ルート形状** | **OSRM (Open Source Routing Machine)** | 2地点間の距離と詳細なルート形状（ポリライン）を取得。**公開デモサーバーは利用規約を確認し、開発・テスト用途に留める。** 安定稼働にはDocker等による自前ホスティングを推奨。 |

---

### IV. 非機能要件 (Non-Functional Requirements)

| ID      | 要件                            | 最小実装における基準                                                                                                                                                                                                                                                                   |
| :------ | :------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **P-1** | **応答時間 (パフォーマンス)**   | 訪問地点数10地点まで、最適化リクエストから**5秒以内**に結果を画面に表示することを目標とする。                                                                                                                                                                                          |
| **P-2** | **堅牢性 (エラーハンドリング)** | 無効な入力に対して適切なエラーメッセージをユーザーに表示し、システムをクラッシュさせない。<br>・Depotが設定されていない場合。<br>・訪問地点が1つ未満の場合。<br>・OSRM APIの呼び出し失敗時（ネットワークエラー、レート制限超過など）。<br>・訪問地点数が上限（10地点）を超過した場合。 |
| **P-3** | **保守性・拡張性**              | ・バックエンド（最適化API）とフロントエンド（UI）の責務を明確に分離する。<br>・将来的な機能拡張（車両追加、容量制約など）を意識し、OR-Toolsのデータモデルを柔軟に設計する。                                                                                                            |
| **P-4** | **費用対効果**                  | 主要コンポーネントにオープンソース技術を採用し、**サーバー費用以外のライセンス費用をゼロ**に抑える。                                                                                                                                                                                   |
| **P-5** | **セキュリティ**                | ・入力データ（緯度・経度）の妥当性検証を行う。<br>・CORS設定を適切に行い、想定外のドメインからのアクセスを制限する。<br>・APIレート制限を実装し、過度なリクエストを防止する。                                                                                                          |

---

### V. 最小実装に向けた検討事項（MVP特有）

#### 1. TSPへのスコープ限定
MVPでは車両数を1台に固定し、VRP（車両ルーティング問題）の最も基本的な形であるTSPを実装する。これにより、容量制約、時間窓制約、複数車両の割り当てといった複雑なロジックをスコープアウトし、コア機能の迅速な市場投入を目指す。

#### 2. 距離計算の現実性とコストのバランス
Google Maps等の商用APIは高精度だが従量課金リスクがある。MVPでは、無料で利用可能なOSRMを活用することで、ユークリッド直線距離ではない、実世界の道路網に基づいた現実的なルートと距離を低コストで実現する。

#### 3. OR-Toolsのデータ構造
OR-Toolsの `RoutingIndexManager` と距離コールバック関数の実装がバックエンドの技術的な核となる。フロントエンドから受け取った緯度・経度リストを元に、OSRMで距離行列を生成し、OR-Toolsに渡す一連のデータフローを正確に実装する。

#### 4. UI/UXに関する考慮事項
最小限の機能の中でも、ユーザーが直感的に操作できる体験を提供する。<br>・地図の初期表示位置を日本の中心付近に設定する。<br>・地点を全てクリアする「リセット」ボタンを設置する。<br>・処理中はローディングインジケーターを表示し、ユーザーに待機状態であることを明確に伝える。

#### 5. デプロイ環境
MVPの公開にあたり、以下にデプロイすることとする。
- フロントエンド: Cloudflare Workers
- バックエンド: Google Cloud Run

#### 6. データの永続化
MVPでは、ユーザーデータの永続化（データベース保存）は実装しない。全てのデータはフロントエンドのステート（セッション内）で管理し、ページリロードでリセットされる。将来的な機能拡張として、結果の保存・読み込み機能を検討する。

---

### VI. API設計の基本方針

#### エンドポイント構成

| エンドポイント  | メソッド | 目的               | リクエスト                                                                                   | レスポンス                                                                       |
| :-------------- | :------- | :----------------- | :------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------- |
| `/api/optimize` | POST     | ルート最適化を実行 | `{ "depot": {"lat": number, "lng": number}, "locations": [{"lat": number, "lng": number}] }` | `{ "route": [index], "total_distance": number, "route_geometries": [polyline] }` |
| `/api/health`   | GET      | ヘルスチェック     | なし                                                                                         | `{ "status": "ok" }`                                                             |

#### エラーレスポンス形式
```json
{
  "error": "エラーの種類",
  "message": "ユーザーフレンドリーなエラーメッセージ"
}
```

---

### VII. 訪問地点数の上限

MVPでは、以下の理由により**訪問地点数の上限を10地点**とする：

1. **パフォーマンス**: 距離行列のサイズがO(n²)で増加するため、OSRM APIへのリクエスト数も急増する。
2. **最適化計算時間**: 地点数が増えるとOR-Toolsの計算時間が長くなる。5秒以内の応答を維持するための現実的な上限。

上限を超えた場合は、フロントエンドで警告を表示し、バックエンドでもバリデーションエラーを返す。
