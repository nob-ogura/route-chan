# 03. フロントエンド実装（React + TypeScript + Leaflet） — 受入基準達成タスク

ゴール（受入基準）:
- 地図クリックで Depot/訪問地点が登録でき、順序番号表示。
- 実行でルートポリラインが描画され、距離と順序が表示。
- 上限超過や未入力時にユーザーに分かるエラー/警告。

## 前提
- Node.js 22.x / npm が利用可能
- `frontend/` は Vite + React + TypeScript で初期化済み（docs/tasks/01.md）
- 依存: `leaflet` が導入済み。ポリライン復号用に `@mapbox/polyline` を追加する。
- バックエンドはローカルで起動可能（`/api/health`, `/api/optimize`）。

## 作業タスク

### 1) 依存と基本セットアップ
- [ ] 依存追加（フロントエンド）：

  ```bash
  cd frontend
  npm i @mapbox/polyline
  ```

- [ ] Leaflet のスタイルを読み込む（どちらかの方法）
  - `index.html` に以下を追加：

    ```html
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    ```

  - もしくは `src/main.tsx` の先頭で CSS を import：

    ```ts
    import "leaflet/dist/leaflet.css";
    ```

- [ ] API ベース URL を環境変数化
  - `frontend/.env`（ローカル開発例）：

    ```env
    VITE_API_BASE_URL=http://localhost:5000
    ```

  - Vite からは `import.meta.env.VITE_API_BASE_URL` で参照。

### 2) 型定義と API クライアント
- [ ] `src/types/index.ts` を作成（型の集約）：

  ```ts
  // frontend/src/types/index.ts
  export type LatLng = { lat: number; lng: number };

  export type OptimizeRequest = {
    depot: LatLng;
    locations: LatLng[];
  };

  export type OptimizeResponse = {
    route: number[]; // locations のインデックス順
    total_distance: number; // meters
    route_geometries: string[]; // polyline6 の配列（各 leg）
  };
  ```

- [ ] `src/services/api.ts` を作成：

  ```ts
  // frontend/src/services/api.ts
  import type { OptimizeRequest, OptimizeResponse } from "../types";

  const BASE = import.meta.env.VITE_API_BASE_URL ?? "";

  export async function health(): Promise<{ status: string }>
  {
    const r = await fetch(`${BASE}/api/health`);
    if (!r.ok) throw new Error(`health failed: ${r.status}`);
    return r.json();
  }

  export async function optimize(payload: OptimizeRequest): Promise<OptimizeResponse>
  {
    const r = await fetch(`${BASE}/api/optimize`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    const data = await r.json();
    if (!r.ok) {
      const msg = (data && (data.message || data.error)) || `status ${r.status}`;
      throw new Error(msg);
    }
    return data as OptimizeResponse;
  }
  ```

### 3) レイアウトとコンポーネント構成
- [ ] `src/components/` を作成し、`MapView.tsx`, `Controls.tsx`, `Summary.tsx` を追加。
- [ ] `src/App.tsx` を編集してレイアウトを用意：

  ```tsx
  // frontend/src/App.tsx
  import { useMemo, useState } from "react";
  import MapView from "./components/MapView";
  import Controls from "./components/Controls";
  import Summary from "./components/Summary";
  import type { LatLng } from "./types";

  type RouteSummary = { km: number; order: number[] } | null;

  export default function App() {
    const [depot, setDepot] = useState<LatLng | null>(null);
    const [locations, setLocations] = useState<LatLng[]>([]);
    const [order, setOrder] = useState<number[] | null>(null); // 最適化後の訪問順（locationsのインデックス）
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [polylines, setPolylines] = useState<string[]>([]); // polyline6

    const maxLocations = 10;
    const canOptimize = !!depot && locations.length >= 1;

    const summary: RouteSummary = useMemo(() => {
      if (!order || !polylines.length) return null;
      // km は Controls 側で受け取って渡す実装でもOK。ここでは簡易に null で扱う。
      return { km: 0, order };
    }, [order, polylines]);

    const resetAll = () => {
      setDepot(null);
      setLocations([]);
      setOrder(null);
      setPolylines([]);
      setError(null);
    };

    return (
      <main style={{ display: "grid", gridTemplateRows: "auto 1fr auto", height: "100dvh" }}>
        <header style={{ padding: 12, borderBottom: "1px solid #ddd" }}>
          <h1 style={{ margin: 0, fontSize: 20 }}>Route-chan</h1>
        </header>
        <section style={{ display: "grid", gridTemplateColumns: "1fr 320px", minHeight: 0 }}>
          <MapView
            depot={depot}
            locations={locations}
            order={order}
            polylines={polylines}
            onMapClick={(p) => {
              setError(null);
              if (!depot) {
                setDepot(p);
                return;
              }
              if (locations.length >= maxLocations) {
                setError(`訪問地点は最大 ${maxLocations} までです。`);
                return;
              }
              setLocations((xs) => [...xs, p]);
            }}
          />
          <Controls
            depot={depot}
            locations={locations}
            loading={loading}
            error={error}
            onError={setError}
            onReset={resetAll}
            onOptimized={(payload) => {
              setOrder(payload.order);
              setPolylines(payload.polylines);
            }}
          />
        </section>
        <footer style={{ padding: 12, borderTop: "1px solid #eee" }}>
          <Summary depot={depot} locations={locations} order={order} />
        </footer>
      </main>
    );
  }
  ```

### 4) MapView.tsx — 地図・地点操作・描画
- [ ] `src/components/MapView.tsx` を実装：
  - 初回クリックを Depot として登録、2回目以降は訪問地点として追加。
  - マーカーを色分け（Depot: 青, 訪問地点: 赤）。
  - マーカーに番号を表示（初期は追加順。最適化後は `order` に従って上書き）。
  - `polylines`（polyline6 の配列）をデコードしてポリライン描画。

  ```tsx
  // frontend/src/components/MapView.tsx
  import { useEffect, useRef } from "react";
  import L from "leaflet";
  import polyline from "@mapbox/polyline";
  import type { LatLng } from "../types";

  type Props = {
    depot: LatLng | null;
    locations: LatLng[];
    order: number[] | null;
    polylines: string[]; // polyline6
    onMapClick: (p: LatLng) => void;
  };

  const JP_CENTER: LatLng = { lat: 36.2048, lng: 138.2529 };

  export default function MapView({ depot, locations, order, polylines, onMapClick }: Props) {
    const mapRef = useRef<L.Map | null>(null);
    const markersRef = useRef<L.LayerGroup | null>(null);
    const routeRef = useRef<L.LayerGroup | null>(null);
    const containerRef = useRef<HTMLDivElement | null>(null);

    // 初期化
    useEffect(() => {
      if (mapRef.current || !containerRef.current) return;
      const m = L.map(containerRef.current).setView([JP_CENTER.lat, JP_CENTER.lng], 5);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors',
      }).addTo(m);
      m.on("click", (e: L.LeafletMouseEvent) => onMapClick({ lat: e.latlng.lat, lng: e.latlng.lng }));
      mapRef.current = m;
      markersRef.current = L.layerGroup().addTo(m);
      routeRef.current = L.layerGroup().addTo(m);
    }, [onMapClick]);

    // マーカー描画（depot + locations）
    useEffect(() => {
      if (!mapRef.current || !markersRef.current) return;
      const layer = markersRef.current;
      layer.clearLayers();

      const addNumberedMarker = (p: LatLng, label: string, color: string) => {
        const html = `<div style="background:${color};color:#fff;border-radius:12px;padding:2px 6px;font-size:12px;border:1px solid #fff;">${label}</div>`;
        const icon = L.divIcon({ html, className: "", iconSize: [0, 0] });
        L.marker([p.lat, p.lng], { icon }).addTo(layer);
      };

      if (depot) addNumberedMarker(depot, "出", "#1976d2");

      // 表示番号: 最適化前は追加順(1..N)、最適化後は order に基づく訪問順(1..N)
      if (order && order.length === locations.length) {
        order.forEach((locIdx, i) => addNumberedMarker(locations[locIdx], String(i + 1), "#d32f2f"));
      } else {
        locations.forEach((p, i) => addNumberedMarker(p, String(i + 1), "#d32f2f"));
      }
    }, [depot, locations, order]);

    // ルート描画（polyline6 -> LatLngs）
    useEffect(() => {
      if (!mapRef.current || !routeRef.current) return;
      const layer = routeRef.current;
      layer.clearLayers();
      polylines.forEach((pl) => {
        const latlngs = polyline.decode(pl, 6).map(([lat, lng]) => [lat, lng]) as [number, number][];
        L.polyline(latlngs, { color: "#1976d2", weight: 4, opacity: 0.8 }).addTo(layer);
      });
    }, [polylines]);

    return <div ref={containerRef} style={{ width: "100%", height: "100%" }} />;
  }
  ```

### 5) Controls.tsx — 実行/リセット/エラー表示
- [ ] `src/components/Controls.tsx` を実装：
  - 最適化の実行ボタン（`loading` 中は無効化）。
  - 未入力（Depot 未設定 or 訪問地点 0）時の警告表示。
  - 上限超過時の警告表示は `App.tsx` 側でセットした `error` を受けて表示。
  - 実行成功時は `onOptimized` コールバックで `order` と `polylines` を親に渡す。距離（km）も計算してサマリーへ渡せるようにしておく（必要に応じて拡張）。

  ```tsx
  // frontend/src/components/Controls.tsx
  import { useState } from "react";
  import * as api from "../services/api";
  import type { LatLng } from "../types";

  type Props = {
    depot: LatLng | null;
    locations: LatLng[];
    loading: boolean;
    error: string | null;
    onError: (m: string | null) => void;
    onReset: () => void;
    onOptimized: (r: { order: number[]; polylines: string[]; km: number }) => void;
  };

  export default function Controls({ depot, locations, loading, error, onError, onReset, onOptimized }: Props) {
    const [busy, setBusy] = useState(false);

    const optimize = async () => {
      onError(null);
      if (!depot || locations.length < 1) {
        onError("出発地点と訪問地点を設定してください。");
        return;
      }
      setBusy(true);
      try {
        const res = await api.optimize({ depot, locations });
        const km = Math.round((res.total_distance / 1000) * 10) / 10; // 小数1桁
        onOptimized({ order: res.route, polylines: res.route_geometries, km });
      } catch (e: any) {
        onError(e?.message ?? "最適化に失敗しました。");
      } finally {
        setBusy(false);
      }
    };

    return (
      <aside style={{ borderLeft: "1px solid #eee", padding: 12, display: "grid", gap: 8 }}>
        <div style={{ fontWeight: 600 }}>操作</div>
        <button onClick={optimize} disabled={busy || loading}>
          {busy ? "計算中…" : "最適化を実行"}
        </button>
        <button onClick={onReset} disabled={busy || loading}>全消去</button>
        {(!depot || locations.length < 1) && (
          <div style={{ color: "#b26a00", background: "#fff3cd", padding: 8, border: "1px solid #ffeeba" }}>
            Depot と訪問地点を設定してください。
          </div>
        )}
        {error && (
          <div style={{ color: "#842029", background: "#f8d7da", padding: 8, border: "1px solid #f5c2c7" }}>
            {error}
          </div>
        )}
        <div style={{ fontSize: 12, color: "#666" }}>
          訪問地点の上限は 10 です。
        </div>
      </aside>
    );
  }
  ```

### 6) Summary.tsx — 距離と順序表示
- [ ] `src/components/Summary.tsx` を実装：
  - 総距離（km）と訪問順序をシンプルに表示。

  ```tsx
  // frontend/src/components/Summary.tsx
  import type { LatLng } from "../types";

  type Props = {
    depot: LatLng | null;
    locations: LatLng[];
    order: number[] | null; // locations のインデックス
    km?: number; // 必要なら App/Controls から渡す
  };

  export default function Summary({ depot, locations, order, km }: Props) {
    return (
      <div style={{ display: "flex", gap: 16, alignItems: "center" }}>
        <div>Depot: {depot ? `${depot.lat.toFixed(4)}, ${depot.lng.toFixed(4)}` : "未設定"}</div>
        <div>地点数: {locations.length}</div>
        <div>
          訪問順序: {order ? order.map((i) => i + 1).join(" → ") : "未計算"}
        </div>
        {typeof km === "number" && <div>総距離: {km} km</div>}
      </div>
    );
  }
  ```

### 7) 動作確認
- [ ] フロントエンドを起動し、以下を確認：
  - 地図クリックで Depot（最初のクリック）と訪問地点（以降）が登録される。
  - マーカーに番号が表示される（最適化前は追加順、最適化後は訪問順）。
  - 訪問地点が 11個目を超えるクリックは拒否され、警告が表示される。
  - Depot 未設定 or 訪問地点 0 の状態で「最適化を実行」を押すと警告が表示される。
  - 実行後にルートのポリラインが地図に描画され、サマリーに距離（km）と順序が表示される。

## 受入基準チェック
- [ ] 地図クリックで Depot/訪問地点が登録でき、順序番号表示（初期は追加順、最適化後は訪問順）。
- [ ] 「最適化を実行」でポリラインが描画され、距離（km）と訪問順序が表示。
- [ ] 上限（10）超過や未入力時に、ユーザーに分かるエラー/警告が表示。

以上で、Plan の「3. フロントエンド実装（React + TypeScript + Leaflet）」の受入基準を満たす具体タスクを網羅する。
