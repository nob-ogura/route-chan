# 02. バックエンド実装（Flask + OR-Tools） — 受入基準達成タスク

ゴール: 「10地点までで3秒以内に最適化APIが応答」「エラー時に JSON で適切な HTTP ステータス」「Health/Optimize が CI でテスト緑」を満たす。

## 前提
- Python 3.11 / pip が利用可能
- `server/requirements.txt` に以下が含まれていること: `flask`, `flask-cors`, `flask-limiter`, `pydantic`, `requests`, `ortools`
- OSRM のベースURLを環境変数で指定（例: `OSRM_BASE_URL=https://router.project-osrm.org`）

## 作業タスク

### 1) スケルトンと設定
- [ ] `server/config.py` を追加し、環境変数を読み込む設定を定義：

  ```python
  import os

  class Config:
      OSRM_BASE_URL = os.getenv("OSRM_BASE_URL", "https://router.project-osrm.org")
      MAX_LOCATIONS = int(os.getenv("MAX_LOCATIONS", "10"))
      TIMEOUT_CONNECT = float(os.getenv("TIMEOUT_CONNECT", "3.0"))
      TIMEOUT_READ = float(os.getenv("TIMEOUT_READ", "5.0"))
      RATE_LIMIT_RULE = os.getenv("RATE_LIMIT_RULE", "60/minute")
      SOLVER_TIME_LIMIT_MS = int(os.getenv("SOLVER_TIME_LIMIT_MS", "3000"))
  ```

- [ ] `server/schemas.py` を追加し、Pydantic モデルを定義（座標の範囲と地点数バリデーション）：

  ```python
  from pydantic import BaseModel, Field, validator
  from typing import List

  class LatLng(BaseModel):
      lat: float = Field(..., ge=-90, le=90)
      lng: float = Field(..., ge=-180, le=180)

  class OptimizeRequest(BaseModel):
      depot: LatLng
      locations: List[LatLng]

      @validator("locations")
      def check_locations(cls, v):
          if not (1 <= len(v) <= 10):  # 後で Config.MAX_LOCATIONS で上書き
              raise ValueError("訪問地点は1から10の間で設定してください")
          return v

  class OptimizeResponse(BaseModel):
      route: List[int]
      total_distance: int
      route_geometries: List[str]
  ```

  備考: 実装時は `Config.MAX_LOCATIONS` を参照し上限を可変にする。

### 2) OSRM クライアント実装
- [ ] `server/osrm_client.py` を追加：

  ```python
  import requests
  from typing import List, Tuple

  class OsrmError(Exception):
      pass

  def _coords_to_path(coords: List[Tuple[float, float]]) -> str:
      # lon,lat;lon,lat;...
      return ";".join([f"{lng},{lat}" for lat, lng in coords])

  def get_distance_matrix(base_url: str, coords: List[Tuple[float, float]], timeout: tuple[float, float]) -> List[List[int]]:
      path = _coords_to_path(coords)
      url = f"{base_url}/table/v1/driving/{path}?annotations=distance"
      try:
          resp = requests.get(url, timeout=timeout)
          resp.raise_for_status()
      except requests.RequestException as e:
          raise OsrmError(f"OSRM table request failed: {e}")
      data = resp.json()
      if "distances" not in data:
          raise OsrmError("OSRM table response missing 'distances'")
      return data["distances"]

  def get_route_geometries(base_url: str, coords: List[Tuple[float, float]], timeout: tuple[float, float]) -> List[str]:
      path = _coords_to_path(coords)
      url = f"{base_url}/route/v1/driving/{path}?overview=full&geometries=polyline6"
      try:
          resp = requests.get(url, timeout=timeout)
          resp.raise_for_status()
      except requests.RequestException as e:
          raise OsrmError(f"OSRM route request failed: {e}")
      data = resp.json()
      if "routes" not in data or not data["routes"]:
          raise OsrmError("OSRM route response missing 'routes'")
      legs = data["routes"][0].get("legs", [])
      return [leg.get("geometry", "") for leg in legs]
  ```

### 3) ソルバ（OR-Tools）実装
- [ ] `server/solver.py` を追加：

  ```python
  from ortools.constraint_solver import pywrapcp, routing_enums_pb2
  from typing import List

  def solve_tsp_distance_matrix(distance_matrix: List[List[int]], time_limit_ms: int = 3000) -> tuple[List[int], int]:
      # depot=0 固定、訪問ノードは 1..N
      manager = pywrapcp.RoutingIndexManager(len(distance_matrix), 1, 0)
      routing = pywrapcp.RoutingModel(manager)

      def distance_callback(from_index, to_index):
          from_node = manager.IndexToNode(from_index)
          to_node = manager.IndexToNode(to_index)
          return int(distance_matrix[from_node][to_node])

      transit_callback_index = routing.RegisterTransitCallback(distance_callback)
      routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

      search_params = pywrapcp.DefaultRoutingSearchParameters()
      search_params.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC
      search_params.local_search_metaheuristic = routing_enums_pb2.LocalSearchMetaheuristic.GUIDED_LOCAL_SEARCH
      search_params.time_limit.FromMilliseconds(time_limit_ms)

      solution = routing.SolveWithParameters(search_params)
      if not solution:
          return [], 0

      # ルート抽出（locations 配列のインデックス: 0..N-1 を返す）
      index = routing.Start(0)
      order = []  # 1..N の訪問順序
      route_distance = 0
      while not routing.IsEnd(index):
          next_index = solution.Value(routing.NextVar(index))
          from_node = manager.IndexToNode(index)
          to_node = manager.IndexToNode(next_index)
          route_distance += routing.GetArcCostForVehicle(index, next_index, 0)
          if to_node != 0:  # depot 以外を locations インデックスに変換（-1）
              order.append(to_node - 1)
          index = next_index

      return order, int(route_distance)
  ```

### 4) 最適化 API とミドルウェア
- [ ] `server/app.py` を拡張し、CORS・レート制限・ログ・エラー処理を追加、`POST /api/optimize` を実装：

  ```python
  from flask import Flask, jsonify, request
  from flask_cors import CORS
  from flask_limiter import Limiter
  from flask_limiter.util import get_remote_address
  from .config import Config
  from .schemas import OptimizeRequest
  from .osrm_client import get_distance_matrix, get_route_geometries, OsrmError
  from .solver import solve_tsp_distance_matrix

  app = Flask(__name__)
  CORS(app, resources={r"/api/*": {"origins": "*"}})
  limiter = Limiter(get_remote_address, app=app, default_limits=[Config.RATE_LIMIT_RULE])

  @app.get("/api/health")
  def health():
      return jsonify(status="ok"), 200

  @app.post("/api/optimize")
  def optimize():
      try:
          payload = request.get_json(force=True, silent=False)
      except Exception:
          return jsonify(error="BAD_REQUEST", message="JSON ボディを解析できませんでした"), 400

      try:
          req = OptimizeRequest(**payload)
      except Exception as e:
          return jsonify(error="VALIDATION_ERROR", message=str(e)), 400

      # Config 上限チェック
      if not (1 <= len(req.locations) <= Config.MAX_LOCATIONS):
          return jsonify(error="INVALID_LOCATION_COUNT", message=f"訪問地点は1から{Config.MAX_LOCATIONS}の間で設定してください。"), 400

      # 座標を (lat, lng) -> (lng, lat) 並びで OSRM 用に変換
      coords = [(req.depot.lat, req.depot.lng)] + [(loc.lat, loc.lng) for loc in req.locations]

      try:
          dm = get_distance_matrix(Config.OSRM_BASE_URL, coords, (Config.TIMEOUT_CONNECT, Config.TIMEOUT_READ))
      except OsrmError as e:
          return jsonify(error="OSRM_TABLE_FAILED", message=str(e)), 502

      route, total = solve_tsp_distance_matrix(dm, time_limit_ms=Config.SOLVER_TIME_LIMIT_MS)

      # 巡回順に沿った座標列を作り、ルート形状を取得
      ordered = [coords[0]] + [coords[i+1] for i in route] + [coords[0]]
      try:
          legs = get_route_geometries(Config.OSRM_BASE_URL, ordered, (Config.TIMEOUT_CONNECT, Config.TIMEOUT_READ))
      except OsrmError as e:
          return jsonify(error="OSRM_ROUTE_FAILED", message=str(e)), 502

      return jsonify(route=route, total_distance=total, route_geometries=legs), 200

  # 共通エラーハンドラ（例）
  @app.errorhandler(429)
  def ratelimit_handler(e):
      return jsonify(error="RATE_LIMITED", message="しばらく待ってから再試行してください。"), 429
  ```

### 5) テスト（ユニット/結合）
- [ ] サーバ用のテスト環境を用意： `server/requirements-dev.txt` を作成し `pytest`, `responses`, `pytest-cov` を追加。
- [ ] `tests/unit/test_solver.py`: 小規模距離行列で期待する順序と距離を検証。
- [ ] `tests/unit/test_osrm_client.py`: 正常応答/異常応答/タイムアウトを `responses` でモックし検証。
- [ ] `tests/integration/test_optimize.py`: Flask の `test_client` と `responses` を併用し、
  - 0地点, 1地点, 10地点, 11地点の境界、
  - バリデーション 400、レート制限 429（必要なら一時的に閾値を下げる）、OSRM 失敗で 502、
  - 正常系で 200 と `route`, `total_distance`, `route_geometries` が返ること、
  を確認。

テスト例（抜粋, solver ユニット）:

  ```python
  from server.solver import solve_tsp_distance_matrix

  def test_solve_simple_triangle():
      dm = [
          [0, 1, 1],
          [1, 0, 2],
          [1, 2, 0],
      ]
      route, total = solve_tsp_distance_matrix(dm, time_limit_ms=200)
      assert set(route) == {0, 1}
      assert total >= 3
  ```

### 6) CI（GitHub Actions）
- [ ] `.github/workflows/server-ci.yml` を追加して Python をセットアップ、依存インストール後に `pytest -q` を実行：

  ```yaml
  name: server-ci
  on: [push, pull_request]
  jobs:
    test:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        - uses: actions/setup-python@v5
          with:
            python-version: '3.11'
        - name: Install deps
          run: |
            cd server
            python -m venv .venv
            . .venv/bin/activate
            pip install -r requirements.txt
            pip install -r requirements-dev.txt
        - name: Run tests
          run: |
            . server/.venv/bin/activate
            pytest -q --maxfail=1 --disable-warnings
  ```

### 7) パフォーマンス計測（3秒以内の目安）
- [ ] ローカル OSRM デモに対して 10地点のケースで計測（初回はウォームアップとして1回捨てる）：

  ```bash
  export OSRM_BASE_URL=https://router.project-osrm.org
  python - <<'PY'
  import time, requests, json
  payload = {
    "depot": {"lat": 35.681236, "lng": 139.767125},
    "locations": [
      {"lat": 35.6895, "lng": 139.6917}, {"lat": 35.6938, "lng": 139.7034},
      {"lat": 35.6580, "lng": 139.7514}, {"lat": 35.7100, "lng": 139.8107},
      {"lat": 35.7295, "lng": 139.7100}, {"lat": 35.7000, "lng": 139.7700},
      {"lat": 35.6655, "lng": 139.7123}, {"lat": 35.6467, "lng": 139.7090},
      {"lat": 35.7064, "lng": 139.6500}, {"lat": 35.6751, "lng": 139.7639}
    ][:10]
  }
  url = "http://localhost:5000/api/optimize"
  # warm-up
  try:
      requests.post(url, json=payload, timeout=30)
  except Exception:
      pass
  t0 = time.time()
  r = requests.post(url, json=payload, timeout=30)
  dt = time.time() - t0
  print("status=", r.status_code, "elapsed=", round(dt, 3), "s")
  print("keys=", list(r.json().keys()))
  PY
  ```

  3秒を超える場合は `SOLVER_TIME_LIMIT_MS` を短縮、OSRM 呼び出し回数の最小化（table 1回 + route 1回）を再確認、タイムアウトを適切化。

## 受入基準チェック
- [ ] 10地点まででローカル計測が概ね 3秒以内（OSRM デモの応答含む）。
- [ ] エラー時に JSON 形式（`error`, `message`）で 400/429/502/500 を適切に返す。
- [ ] CI（GitHub Actions）で `server` のユニット/結合テストが緑。

以上で、Plan の「2. バックエンド実装（Flask + OR-Tools）」の受入基準を満たすための具体タスクを網羅する。

